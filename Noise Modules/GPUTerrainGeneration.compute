#include "Assets/Planetary Terrain/Scripts/ComputeShaders/FastNoiseGPU.compute"
#include "Assets/Planetary Terrain/Scripts/ComputeShaders/NoiseOperatorsGPU.compute"


float scale;
float3 trPosition;
float radius;
float4 rotation;
float noiseDiv;


float3 RotateVector(float4 q, float3 v)
{

    float num = q.x * 2.0;
    float num2 = q.y * 2.0;
    float num3 = q.z * 2.0;
    float num4 = q.x * num;
    float num5 = q.y * num2;
    float num6 = q.z * num3;
    float num7 = q.x * num2;
    float num8 = q.x * num3;
    float num9 = q.y * num3;
    float num10 = q.w * num;
    float num11 = q.w * num2;
    float num12 = q.w * num3;

    float3 result;
    result.x = (1.0 - (num5 + num6)) * v.x + (num7 - num12) * v.y + (num8 + num11) * v.z;
    result.y = (num7 + num12) * v.x + (1.0 - (num4 + num6)) * v.y + (num9 - num10) * v.z;
    result.z = (num8 - num11) * v.x + (num9 + num10) * v.y + (1.0 - (num4 + num5)) * v.z;

    return result;
}


//Using conditional branching (if/else) is not optimal as GPUs aren't optimized for it. In this case it is still better for performance because a lot less noise has to be computed.
//Conditional branching is not used in any of the shaders generated by the Compute Shader saving node. This code was modified.

float GetNoise(float x, float y, float z)
{
    float f0_0 = 0;
    float sel1 = 0;

    SetParameters(34, 0.45, 20, 2, 1);
    float f1_2 = GetSimplexFractal(x, y, z);
    float sel = Select(f1_2, -0.500000, 50.000000);

    if (sel == 0)
    {
        SetParameters(42, 0.8, 20, 2, 1);
        float f2_2 = GetSimplexFractal(x, y, z);

        sel1 = Select(f2_2, 0.200000, 6.666667);
        float f1_0 = 0;

        if (sel1 == 0)
        {
            SetParameters(42, 100, 10, 2, 0);
            float f3_0 = GetSimplexFractal(x, y, z);
            float f2_1 = mad(f3_0, 0.125000, -0.750000);
            f1_0 = f2_1;
        }

        else if (sel1 == 1)
        {
            SetParameters(42, 170, 10, 1.9, 2);
            float f2_0 = GetSimplexFractal(x, y, z);
            f1_0 = f2_0;
        }

        else
        {
            SetParameters(42, 100, 10, 2, 0);
            float f3_0 = GetSimplexFractal(x, y, z);
            float f2_1 = mad(f3_0, 0.125000, -0.750000);

            SetParameters(42, 170, 10, 1.9, 2);
            float f2_0 = GetSimplexFractal(x, y, z);

            f1_0 = lerp(f2_1, f2_0, sel1);
        }

        f0_0 = f1_0;
    }

    else if (sel == 1)
    {
        float f1_1 = -1.000000;
        f0_0 = f1_1;
    }

    else
    {
        SetParameters(42, 0.8, 20, 2, 1);
        float f2_2 = GetSimplexFractal(x, y, z);

        sel1 = Select(f2_2, 0.200000, 6.666667);
        float f1_0 = 0;

        if (sel1 == 0)
        {

            SetParameters(42, 100, 10, 2, 0);
            float f3_0 = GetSimplexFractal(x, y, z);
            float f2_1 = mad(f3_0, 0.125000, -0.750000);
            f1_0 = f2_1;
        }

        else if (sel1 == 1)
        {

            SetParameters(42, 170, 10, 1.9, 2);
            float f2_0 = GetSimplexFractal(x, y, z);
            f1_0 = f2_0;
        }

        else
        {
            SetParameters(42, 100, 10, 2, 0);
            float f3_0 = GetSimplexFractal(x, y, z);
            float f2_1 = mad(f3_0, 0.125000, -0.750000);

            SetParameters(42, 170, 10, 1.9, 2);
            float f2_0 = GetSimplexFractal(x, y, z);

            f1_0 = lerp(f2_1, f2_0, sel1);
        }

        float f1_1 = -1.000000;
        f0_0 = lerp(f1_0, f1_1, sel);
    }

    return (f0_0 + 1) * 0.5f;
}


RWStructuredBuffer<float3> dataBuffer;

#pragma kernel ComputePositions
[numthreads(256, 1, 1)] void ComputePositions(uint3 id
                                              : SV_DispatchThreadID) {
    dataBuffer[id.x] *= scale;
    dataBuffer[id.x] = RotateVector(rotation, dataBuffer[id.x]);

    dataBuffer[id.x] += trPosition;
    dataBuffer[id.x] = normalize(dataBuffer[id.x]); 
    float height = GetNoise(dataBuffer[id.x].x, dataBuffer[id.x].y, dataBuffer[id.x].z);
    dataBuffer[id.x] *= radius;
    dataBuffer[id.x] *= (noiseDiv + height) / noiseDiv;
}


#pragma kernel ComputeHeightmap
[numthreads(256, 1, 1)] void ComputeHeightmap(uint3 id: SV_DispatchThreadID) {
    
    dataBuffer[id.x].x = GetNoise(dataBuffer[id.x].x, dataBuffer[id.x].y, dataBuffer[id.x].z);
    
}